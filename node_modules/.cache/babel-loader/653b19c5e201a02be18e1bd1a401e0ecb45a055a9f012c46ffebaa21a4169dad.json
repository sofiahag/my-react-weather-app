{"ast":null,"code":"import invariant from 'invariant';\nimport stripDiacritics from './stripDiacritics';\nvar CASE_INSENSITIVE = 'i';\nvar COMBINING_MARKS = /[\\u0300-\\u036F]/;\n// Export for testing.\nexport function escapeStringRegexp(str) {\n  !(typeof str === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`escapeStringRegexp` expected a string.') : invariant(false) : void 0; // Escape characters with special meaning either inside or outside character\n  // sets. Use a simple backslash escape when it’s always valid, and a \\unnnn\n  // escape when the simpler form would be disallowed by Unicode patterns’\n  // stricter grammar.\n\n  return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\nexport default function getMatchBounds(subject, str) {\n  var search = new RegExp(escapeStringRegexp(stripDiacritics(str)), CASE_INSENSITIVE);\n  var matches = search.exec(stripDiacritics(subject));\n  if (!matches) {\n    return null;\n  }\n  var start = matches.index;\n  var matchLength = matches[0].length; // Account for combining marks, which changes the indices.\n\n  if (COMBINING_MARKS.test(subject)) {\n    // Starting at the beginning of the subject string, check for the number of\n    // combining marks and increment the start index whenever one is found.\n    for (var ii = 0; ii <= start; ii++) {\n      if (COMBINING_MARKS.test(subject[ii])) {\n        start += 1;\n      }\n    } // Similarly, increment the length of the match string if it contains a\n    // combining mark.\n\n    for (var _ii = start; _ii <= start + matchLength; _ii++) {\n      if (COMBINING_MARKS.test(subject[_ii])) {\n        matchLength += 1;\n      }\n    }\n  }\n  return {\n    end: start + matchLength,\n    start: start\n  };\n}","map":{"version":3,"names":["invariant","stripDiacritics","CASE_INSENSITIVE","COMBINING_MARKS","escapeStringRegexp","str","process","env","NODE_ENV","replace","getMatchBounds","subject","search","RegExp","matches","exec","start","index","matchLength","length","test","ii","_ii","end"],"sources":["/Users/Fia/opt/my-react-weather-app/node_modules/react-bootstrap-typeahead/es/utils/getMatchBounds.js"],"sourcesContent":["import invariant from 'invariant';\nimport stripDiacritics from './stripDiacritics';\nvar CASE_INSENSITIVE = 'i';\nvar COMBINING_MARKS = /[\\u0300-\\u036F]/;\n// Export for testing.\nexport function escapeStringRegexp(str) {\n  !(typeof str === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`escapeStringRegexp` expected a string.') : invariant(false) : void 0; // Escape characters with special meaning either inside or outside character\n  // sets. Use a simple backslash escape when it’s always valid, and a \\unnnn\n  // escape when the simpler form would be disallowed by Unicode patterns’\n  // stricter grammar.\n\n  return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\nexport default function getMatchBounds(subject, str) {\n  var search = new RegExp(escapeStringRegexp(stripDiacritics(str)), CASE_INSENSITIVE);\n  var matches = search.exec(stripDiacritics(subject));\n\n  if (!matches) {\n    return null;\n  }\n\n  var start = matches.index;\n  var matchLength = matches[0].length; // Account for combining marks, which changes the indices.\n\n  if (COMBINING_MARKS.test(subject)) {\n    // Starting at the beginning of the subject string, check for the number of\n    // combining marks and increment the start index whenever one is found.\n    for (var ii = 0; ii <= start; ii++) {\n      if (COMBINING_MARKS.test(subject[ii])) {\n        start += 1;\n      }\n    } // Similarly, increment the length of the match string if it contains a\n    // combining mark.\n\n\n    for (var _ii = start; _ii <= start + matchLength; _ii++) {\n      if (COMBINING_MARKS.test(subject[_ii])) {\n        matchLength += 1;\n      }\n    }\n  }\n\n  return {\n    end: start + matchLength,\n    start: start\n  };\n}"],"mappings":"AAAA,OAAOA,SAAS,MAAM,WAAW;AACjC,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,IAAIC,gBAAgB,GAAG,GAAG;AAC1B,IAAIC,eAAe,GAAG,iBAAiB;AACvC;AACA,OAAO,SAASC,kBAAkBA,CAACC,GAAG,EAAE;EACtC,EAAE,OAAOA,GAAG,KAAK,QAAQ,CAAC,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGR,SAAS,CAAC,KAAK,EAAE,yCAAyC,CAAC,GAAGA,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;EAC9J;EACA;EACA;;EAEA,OAAOK,GAAG,CAACI,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC;AAC1E;AACA,eAAe,SAASC,cAAcA,CAACC,OAAO,EAAEN,GAAG,EAAE;EACnD,IAAIO,MAAM,GAAG,IAAIC,MAAM,CAACT,kBAAkB,CAACH,eAAe,CAACI,GAAG,CAAC,CAAC,EAAEH,gBAAgB,CAAC;EACnF,IAAIY,OAAO,GAAGF,MAAM,CAACG,IAAI,CAACd,eAAe,CAACU,OAAO,CAAC,CAAC;EAEnD,IAAI,CAACG,OAAO,EAAE;IACZ,OAAO,IAAI;EACb;EAEA,IAAIE,KAAK,GAAGF,OAAO,CAACG,KAAK;EACzB,IAAIC,WAAW,GAAGJ,OAAO,CAAC,CAAC,CAAC,CAACK,MAAM,CAAC,CAAC;;EAErC,IAAIhB,eAAe,CAACiB,IAAI,CAACT,OAAO,CAAC,EAAE;IACjC;IACA;IACA,KAAK,IAAIU,EAAE,GAAG,CAAC,EAAEA,EAAE,IAAIL,KAAK,EAAEK,EAAE,EAAE,EAAE;MAClC,IAAIlB,eAAe,CAACiB,IAAI,CAACT,OAAO,CAACU,EAAE,CAAC,CAAC,EAAE;QACrCL,KAAK,IAAI,CAAC;MACZ;IACF,CAAC,CAAC;IACF;;IAGA,KAAK,IAAIM,GAAG,GAAGN,KAAK,EAAEM,GAAG,IAAIN,KAAK,GAAGE,WAAW,EAAEI,GAAG,EAAE,EAAE;MACvD,IAAInB,eAAe,CAACiB,IAAI,CAACT,OAAO,CAACW,GAAG,CAAC,CAAC,EAAE;QACtCJ,WAAW,IAAI,CAAC;MAClB;IACF;EACF;EAEA,OAAO;IACLK,GAAG,EAAEP,KAAK,GAAGE,WAAW;IACxBF,KAAK,EAAEA;EACT,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}